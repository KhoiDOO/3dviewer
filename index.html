<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Object Viewer</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            padding: 10px;
            background: rgba(0,0,0,0.5);
            color: white;
            border-radius: 5px;
        }
        select {
            margin: 5px;
        }
        #info {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 10px;
            background: rgba(0,0,0,0.5);
            color: white;
            border-radius: 5px;
            max-width: 250px;
        }
        #instructions {
            position: absolute;
            bottom: 10px;
            left: 10px;
            padding: 10px;
            background: rgba(0,0,0,0.5);
            color: white;
            border-radius: 5px;
            max-width: 300px;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div id="controls">
        <label for="dataset-select">Dataset:</label>
        <select id="dataset-select"></select>
        <br>
        <label for="object-select">Object:</label>
        <select id="object-select"></select>
        <br>
        <label for="view-mode-select">View Mode:</label>
        <select id="view-mode-select">
            <option value="surface">Surface</option>
            <option value="wireframe">Wireframe</option>
            <option value="both">Both</option>
        </select>
    </div>

    <div id="debug-status" style="position:absolute;bottom:10px;right:10px;padding:8px;background:rgba(0,0,0,0.6);color:#0f0;border-radius:4px;font-size:12px;max-width:320px;">
        <div><strong>Debug:</strong></div>
        <div id="debug-msg">waiting for /data...</div>
    </div>

    <div id="info">
        <div><strong>Object Info:</strong></div>
        <div id="vertices-count">Vertices: -</div>
        <div id="faces-count">Faces: -</div>
        <div id="file-name">File: -</div>
    </div>

    <div id="instructions">
        <div><strong>Controls:</strong></div>
        <div><strong>Rotation:</strong></div>
        <div>• A/D: Rotate Y-axis</div>
        <div>• W/S: Rotate X-axis</div>
        <div>• T/G: Rotate Z-axis</div>
        <div><strong>Navigation:</strong></div>
        <div>• ←/→: Previous/Next object</div>
        <div><strong>Mouse:</strong></div>
        <div>• Drag: Orbit camera</div>
        <div>• Scroll: Zoom in/out</div>
    </div>

    <script type="module">
        import * as THREE from 'https://cdn.skypack.dev/three@0.132.2';
        import { OBJLoader } from 'https://cdn.skypack.dev/three@0.132.2/examples/jsm/loaders/OBJLoader.js';
        import { OrbitControls } from 'https://cdn.skypack.dev/three@0.132.2/examples/jsm/controls/OrbitControls.js';

        let scene, camera, renderer, controls, currentObject;

        const datasetSelect = document.getElementById('dataset-select');
        const objectSelect = document.getElementById('object-select');
        const viewModeSelect = document.getElementById('view-mode-select');
        let fileData = {};

        let wireframeObject;

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xdddddd);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 5;

            renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(1, 1, 1);
            scene.add(directionalLight);

            animate();
            loadData();
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        function loadData() {
            console.info('loadData(): starting fetch /data');
            const debugMsg = document.getElementById('debug-msg');
            debugMsg.textContent = 'fetching /data...';

            // add a cache-busting query and ask fetch to not use cache/service-worker cached responses
            const dataUrl = '/data?bust=' + Date.now();
            fetch(dataUrl, { cache: 'no-store' })
                .then(response => {
                    console.info('loadData(): /data response status', response.status);
                    if (!response.ok) {
                        throw new Error('Server returned ' + response.status);
                    }
                    return response.text().then(text => {
                        // try parse as JSON first; if it looks like HTML, fallback
                        try {
                            return JSON.parse(text);
                        } catch (e) {
                            // If response starts with '<', it's probably HTML (index.html)
                            if (text.trim().startsWith('<')) {
                                throw new Error('non-json-response');
                            }
                            // maybe it's JSON but parse failed due to BOM or similar; rethrow
                            throw e;
                        }
                    });
                })
                .then(data => {
                    console.info('loadData(): parsed JSON', data && Object.keys(data).length);
                    fileData = data;
                    const datasets = Object.keys(data);
                    datasets.forEach(dataset => {
                        const option = document.createElement('option');
                        option.value = dataset;
                        option.textContent = dataset;
                        datasetSelect.appendChild(option);
                    });
                    datasetSelect.dispatchEvent(new Event('change'));
                    debugMsg.textContent = '/data fetched OK';

                    // Now request server-side status to confirm the server saw the request
                    const statusUrl = '/data/status?bust=' + Date.now();
                    fetch(statusUrl, { cache: 'no-store' })
                        .then(r => r.json())
                        .then(status => {
                            console.info('/data/status', status);
                            debugMsg.textContent = '/data status: count=' + status.count + ', last=' + status.last_request_time;
                        })
                        .catch(err => {
                            console.warn('Could not fetch /data/status', err);
                            debugMsg.textContent = '/data fetched but /data/status failed';
                        });
                })
                .catch(err => {
                    console.error('loadData(): failed to fetch /data', err);
                    // If error indicates HTML was returned, try the fallback
                    if (err && err.message === 'non-json-response') {
                        debugMsg.textContent = '/data returned HTML; trying fallback /data_files.json';
                        fetch('/data_files.json', { cache: 'no-store' })
                            .then(r => {
                                if (!r.ok) throw new Error('fallback returned ' + r.status);
                                return r.json();
                            })
                            .then(fallbackData => {
                                console.info('Fallback data_files.json loaded', fallbackData && Object.keys(fallbackData).length);
                                fileData = fallbackData;
                                const datasets = Object.keys(fallbackData);
                                datasets.forEach(dataset => {
                                    const option = document.createElement('option');
                                    option.value = dataset;
                                    option.textContent = dataset;
                                    datasetSelect.appendChild(option);
                                });
                                datasetSelect.dispatchEvent(new Event('change'));
                                debugMsg.textContent = 'Fallback loaded /data_files.json';
                            })
                            .catch(ferr => {
                                console.error('Fallback failed', ferr);
                                debugMsg.textContent = 'ERROR fallback /data_files.json: ' + ferr.message;
                            });
                        return;
                    }

                    debugMsg.textContent = 'ERROR fetching /data: ' + err.message;
                });
        }

        datasetSelect.addEventListener('change', () => {
            const selectedDataset = datasetSelect.value;
            const objects = fileData[selectedDataset];
            objectSelect.innerHTML = '';
            objects.forEach(objectPath => {
                const option = document.createElement('option');
                option.value = objectPath;
                const fileName = objectPath.split('/').pop();
                option.textContent = fileName;
                objectSelect.appendChild(option);
            });
            objectSelect.dispatchEvent(new Event('change'));
        });

        objectSelect.addEventListener('change', () => {
            const selectedObjectPath = objectSelect.value;
            if (selectedObjectPath) {
                loadObject(selectedObjectPath);
            }
        });

        viewModeSelect.addEventListener('change', () => {
            updateViewMode();
        });

        function updateViewMode() {
            if (wireframeObject) {
                scene.remove(wireframeObject);
                wireframeObject = null;
            }

            if (!currentObject) return;

            const mode = viewModeSelect.value;

            // Make sure to set the material on all meshes
            currentObject.traverse((child) => {
                if (child.isMesh) {
                    child.material.wireframe = (mode === 'wireframe');
                }
            });

            if (mode === 'both') {
                 currentObject.traverse((child) => {
                    if (child.isMesh) {
                        child.material.wireframe = false;
                    }
                });

                wireframeObject = currentObject.clone();
                const wireframeMaterial = new THREE.MeshBasicMaterial({
                    color: 0x000000,
                    wireframe: true,
                });

                wireframeObject.traverse((child) => {
                    if (child.isMesh) {
                        child.material = wireframeMaterial;
                    }
                });
                scene.add(wireframeObject);
            }
        }

        function updateObjectInfo(object) {
            let totalVertices = 0;
            let totalFaces = 0;

            object.traverse((child) => {
                if (child.isMesh && child.geometry) {
                    const geometry = child.geometry;
                    if (geometry.attributes.position) {
                        totalVertices += geometry.attributes.position.count;
                    }
                    if (geometry.index) {
                        totalFaces += geometry.index.count / 3;
                    } else if (geometry.attributes.position) {
                        totalFaces += geometry.attributes.position.count / 3;
                    }
                }
            });

            document.getElementById('vertices-count').textContent = `Vertices: ${totalVertices.toLocaleString()}`;
            document.getElementById('faces-count').textContent = `Faces: ${Math.floor(totalFaces).toLocaleString()}`;
        }

        function loadObject(path) {
            if (currentObject) {
                scene.remove(currentObject);
                currentObject = null;
            }
            if (wireframeObject) {
                scene.remove(wireframeObject);
                wireframeObject = null;
            }
            const loader = new OBJLoader();
            loader.load(
                `/object?path=${encodeURIComponent(path)}`,
                (object) => {
                    currentObject = object;
                    
                    // Update file name display
                    const fileName = path.split('/').pop();
                    document.getElementById('file-name').textContent = `File: ${fileName}`;
                    
                    // Update object info
                    updateObjectInfo(object);
                    
                    // Center the object
                    const box = new THREE.Box3().setFromObject(object);
                    const center = box.getCenter(new THREE.Vector3());
                    object.position.sub(center);
                    scene.add(object);

                    updateViewMode();

                    // Adjust camera to fit the object
                    const size = box.getSize(new THREE.Vector3());
                    const maxDim = Math.max(size.x, size.y, size.z);
                    const fov = camera.fov * (Math.PI / 180);
                    let cameraZ = Math.abs(maxDim / 2 * Math.tan(fov * 2));
                    cameraZ *= 1.5; // zoom out a bit
                    
                    camera.position.z = cameraZ;
                    controls.update();
                },
                (xhr) => {
                    console.log((xhr.loaded / xhr.total * 100) + '% loaded');
                },
                (error) => {
                    console.error('An error happened', error);
                }
            );
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }, false);

        init();

        function handleKeyDown(event) {
            const rotationSpeed = 0.05;
            if (currentObject) {
                switch (event.key) {
                    // Rotation controls
                    case 'a':
                        currentObject.rotation.y -= rotationSpeed;
                        if (wireframeObject) wireframeObject.rotation.y -= rotationSpeed;
                        break;
                    case 'd':
                        currentObject.rotation.y += rotationSpeed;
                        if (wireframeObject) wireframeObject.rotation.y += rotationSpeed;
                        break;
                    case 'w':
                        currentObject.rotation.x -= rotationSpeed;
                        if (wireframeObject) wireframeObject.rotation.x -= rotationSpeed;
                        break;
                    case 's':
                        currentObject.rotation.x += rotationSpeed;
                        if (wireframeObject) wireframeObject.rotation.x += rotationSpeed;
                        break;
                    case 't':
                        currentObject.rotation.z += rotationSpeed;
                        if (wireframeObject) wireframeObject.rotation.z += rotationSpeed;
                        break;
                    case 'g':
                        currentObject.rotation.z -= rotationSpeed;
                        if (wireframeObject) wireframeObject.rotation.z -= rotationSpeed;
                        break;
                }
            }

             // Navigation controls
            switch (event.key) {
                case 'ArrowLeft':
                    if (objectSelect.options.length > 0) {
                        let newIndex = objectSelect.selectedIndex - 1;
                        if (newIndex < 0) {
                            newIndex = objectSelect.options.length - 1;
                        }
                        objectSelect.selectedIndex = newIndex;
                        objectSelect.dispatchEvent(new Event('change'));
                    }
                    break;
                case 'ArrowRight':
                    if (objectSelect.options.length > 0) {
                        let newIndex = objectSelect.selectedIndex + 1;
                        if (newIndex >= objectSelect.options.length) {
                            newIndex = 0;
                        }
                        objectSelect.selectedIndex = newIndex;
                        objectSelect.dispatchEvent(new Event('change'));
                    }
                    break;
            }
        }

        window.addEventListener('keydown', handleKeyDown);
    </script>
</body>
</html>
